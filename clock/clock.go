package clock

import (
	"errors"
	"fmt"
	"slices"
	"time"
)

// A TaskCallback is the callback registered for a [FutureTask].
type TaskCallback func() error

// A SafeTaskCallback is the callback that registered for a [FutureTask] that
// can't generate an err.r
type SafeTaskCallback func()

func (t SafeTaskCallback) toTask() TaskCallback { return func() error { t(); return nil } }

// A FutureTask represents a task to run when simulated time advances past the
// specified Time value.
type FutureTask struct {
	Time time.Time
	Task TaskCallback
}

// Clock simulates passing of time, as well as potential future tasks. Simulated
// Time can be advanced using [Clock.Advance] or [Clock.RunAll] which will
// execute all tasks at the simulated time they are supposed to run. Both
// functions will return an error if any of the executed tasks return an error;
// but they can also panic!
//
// Advancing the clock panics if the task queue isn't decreasing, i.e, tasks are
// adding new tasks. This will happen if a JavaScript call to setInterval isn't
// cleared before calling [RunAll], or a setInterval callback that continuously
// adds a new immediate callback, or a microtasks creating a new microtask.
//
// This is designed to panic rather than return an error, as an error represents
// an error generated by the code being tested. You may choose to ignore it, or
// even assert on it's precense when testing error conditions. But a task list
// that doesn't decrease is an error in the test itself, that the developer
// should be notified of; which is why the design is a panic.
type Clock struct {
	Time time.Time
	// Sets the number of times the function allows running without seeing a
	// reduction in task list size. I.e., the task list doesn't need to be
	// emptied after the specified no of tasks executed, but the list of pending
	// tasks must at least have been lower. The counter is reset every time a
	// new minimum of remaining number of tasks is noticed
	MaxLoopWithoutDecrement int
	tasks                   []FutureTask
	// The tasks in the microtask queue must execute before the next task in the
	// task queue, even if next tasks is set to execute now.
	microtasks []TaskCallback
}

// Creates a new clock. If the options don't set a specific time, the clock is
// initialised with the current system time as the initial simulated wall clock
// time.
//
// If tests depend on an actual time, e.g., verifying a local time displaed in
// the user interface, then test code should pass a concrete starting time;
// letting the test execution be independent of the running environment.
//
// The option should only be left out if the test only needs to verify behaviour
// due to passing of time. E.g., testing throttling/debouncing/timeouts.
func New(options ...NewClockOption) *Clock {
	c := &Clock{
		MaxLoopWithoutDecrement: 100,
	}
	for _, o := range options {
		o(c)
	}
	if c.Time.IsZero() {
		c.Time = time.Now()
	}
	return c
}

func (c *Clock) runMicrotasks() []error {
	var errs []error
	minLength := len(c.microtasks)
	count := 0
	for len(c.microtasks) > 0 {
		t := c.microtasks[0]
		c.microtasks = c.microtasks[1:]
		if err := t(); err != nil {
			errs = append(errs, err)
		}
		newLength := len(c.microtasks)
		if newLength < minLength {
			minLength = newLength
			count = 0
		} else {
			count++
			if count > c.MaxLoopWithoutDecrement {
				panic("Clock: Size of pending microtasks isn't decreasing. Are tasks adding new tasks?")
			}
		}
	}
	return errs
}

func (c *Clock) runWhile(predicate func() bool) []error {
	var errs []error
	minLength := len(c.tasks)
	count := 0
	for predicate() {
		task := c.tasks[0]
		c.tasks = c.tasks[1:]
		c.Time = task.Time
		if err := task.Task(); err != nil {
			errs = append(errs, err)
		}
		errs = append(errs, c.runMicrotasks()...)
		newLength := len(c.tasks)
		if newLength < minLength {
			minLength = newLength
			count = 0
		} else {
			count++
			if count > c.MaxLoopWithoutDecrement {
				panic("Clock: Size of pending tasks isn't decreasing. Are tasks adding new tasks?")
			}
		}

	}
	return errs
}

// Advances the clock by the specified amount of time. Any new tasks being
// registered while running will be executed; if they are scheduled _before_ the
// timeout. When returning, the clock time will be the current time + the
// duration.
//
// Returns an error if any of the added tasks generate an error. Panics if the
// task list doesn't decrease in size. See [Clock] documentation for more info.
func (c *Clock) Advance(d time.Duration) error {
	endTime := c.Time.Add(d)
	errs := c.runWhile(func() bool {
		return len(c.tasks) > 0 && !c.tasks[0].Time.After(endTime)
	})
	c.Time = endTime
	return errors.Join(errs...)
}

func (c *Clock) AddMicrotask(task TaskCallback) {
	c.microtasks = append(c.microtasks, task)
}
func (c *Clock) AddSafeMicrotask(task SafeTaskCallback) { c.AddMicrotask(task.toTask()) }

// Schedules a task to run at a specified time in the future. Panics if the time
// is in the past.
func (c *Clock) AddTask(when FutureTimeSpec, task TaskCallback) {
	taskTime := when(c.Time)
	if taskTime.Before(c.Time) {
		panic(
			fmt.Sprintf(
				"Clock.AddTask: Adding task to run in the past\n  Current time: %v\n  Task time: %v",
				c.Time,
				taskTime,
			),
		)
	}
	future := FutureTask{
		Time: taskTime,
		Task: task,
	}
	idx := slices.IndexFunc(c.tasks, func(t FutureTask) bool { return t.Time.After(taskTime) })
	if idx >= 0 {
		c.tasks = slices.Insert(c.tasks, idx, future)
	} else {
		c.tasks = append(c.tasks, future)
	}
}

// Schedules a task to run at a specified time in the future. Panics if the time
// is in the past.
func (c *Clock) AddSafeTask(when FutureTimeSpec, task SafeTaskCallback) {
	c.AddTask(when, task.toTask())
}

// Keeps running as long as there are tasks in the task queue. New tasks
// appended while running will also run. When returning, the current time will
// be the time of the last executed task.
//
// Returns an error if any of the added tasks generate an error. Panics if the
// task list doesn't decrease in size. See [Clock] documentation for more info.
func (c *Clock) RunAll() error {
	errs := c.runWhile(func() bool { return len(c.tasks) > 0 })

	return errors.Join(errs...)
}

/* -------- Options -------- */

// NewClockOption are used to initialize a new [Clock]
type NewClockOption func(*Clock)

// Initializes the clock's simulated time from a concrete [time.Time] value.
func OfTime(t time.Time) NewClockOption {
	return func(c *Clock) {
		c.Time = t
	}
}

// Initializes the clock's simulated time based on an RFC3339 time string.
// Panics if the string is not valid.
//
// This is intended for the use case where the time is a constant in a test
// case, and as such will either fail or succeed consistently. For variable
// input, the caller should parse the time and use [OfTime] instead.
func OfIsoString(iso string) NewClockOption {
	t, err := time.Parse(time.RFC3339, iso)
	if err != nil {
		panic(fmt.Errorf("clock.IsoTime: error parsing string - %w", err))
	}
	return OfTime(t)
}

/* -------- DelaySpecifier -------- */

// FutureTimeSpec calback is called to calculate when a task should execute
type FutureTimeSpec func(current time.Time) time.Time

// Relative is a FutureTimeSpec indicating a relative time to the current
// simulated time. Panics if the duration is negative.
func Relative(d time.Duration) FutureTimeSpec {
	return func(t time.Time) time.Time {
		return t.Add(d)
	}
}
